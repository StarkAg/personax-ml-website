<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Persona Dashboard - Interactive Analytics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/lib/ml-matrix.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.2/dist/simple-statistics.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        .dashboard-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        .dashboard-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .filter-active {
            background-color: #2563eb;
            color: white;
        }
        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
        }
        .chart-container-3d {
            height: 600px;
        }
        .chart-container-small {
            height: 400px;
        }
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .sidebar {
            transition: all 0.3s ease;
        }
        .sidebar.collapsed {
            width: 60px;
        }
        .sidebar.collapsed .sidebar-content {
            display: none;
        }
        .alert {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .alert-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Navigation -->
    <nav class="bg-white shadow-sm border-b">
        <div class="px-6 py-4 flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <a href="index.html" class="text-blue-600 hover:text-blue-800">
                    <i class="fas fa-arrow-left mr-2"></i>Back to Project
                </a>
                <h1 class="text-2xl font-bold text-gray-800">Customer Persona Dashboard</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="toggleSidebar" class="p-2 rounded-lg hover:bg-gray-100">
                    <i class="fas fa-bars"></i>
                </button>
                <button id="exportBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                    <i class="fas fa-download mr-2"></i>Export Report
                </button>
            </div>
        </div>
    </nav>

    <div class="flex h-screen">
        <!-- Sidebar -->
        <div id="sidebar" class="sidebar bg-white shadow-lg w-80 overflow-y-auto">
            <div class="sidebar-content p-6">
                <!-- Data Upload Section -->
                <div class="dashboard-card p-6 mb-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-upload mr-2"></i>Data Upload
                    </h3>
                    <div class="space-y-4">
                        <div class="alert alert-info">
                            <strong>CSV Format:</strong> Your CSV should have columns like: CustomerID, InvoiceDate, Amount (or similar). Dates should be in YYYY-MM-DD format.
                        </div>
                        <input type="file" id="csvFile" accept=".csv" class="w-full p-2 border rounded-lg">
                        <button id="loadData" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-700">
                            <i class="fas fa-database mr-2"></i>Load Customer Data
                        </button>
                        <div id="dataInfo" class="text-sm text-gray-600 hidden">
                            <p>Loaded: <span id="rowCount">0</span> records</p>
                            <p>Columns: <span id="columnCount">0</span></p>
                            <p id="columnMapping" class="mt-2 text-xs"></p>
                        </div>
                    </div>
                </div>

                <!-- RFM Parameters -->
                <div class="dashboard-card p-6 mb-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-sliders-h mr-2"></i>RFM Parameters
                    </h3>
                    <div class="space-y-4">
                        <button id="calculateRFM" class="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700">
                            <i class="fas fa-calculator mr-2"></i>Calculate RFM
                        </button>
                    </div>
                </div>

                <!-- Clustering Options -->
                <div class="dashboard-card p-6 mb-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-project-diagram mr-2"></i>Clustering
                    </h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Number of Clusters</label>
                            <input type="number" id="numClusters" value="4" min="2" max="10" class="w-full p-2 border rounded-lg">
                        </div>
                        <button id="runClustering" class="w-full bg-purple-600 text-white py-2 rounded-lg hover:bg-purple-700">
                            <i class="fas fa-brain mr-2"></i>Run Clustering
                        </button>
                    </div>
                </div>

                <!-- Filters -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-filter mr-2"></i>Filters
                    </h3>
                    <div class="space-y-3">
                        <button class="filter-btn w-full text-left p-2 rounded-lg border hover:bg-gray-50" data-filter="all">
                            <i class="fas fa-users mr-2"></i>All Customers
                        </button>
                        <button class="filter-btn w-full text-left p-2 rounded-lg border hover:bg-gray-50" data-filter="high-value">
                            <i class="fas fa-crown mr-2"></i>High Value
                        </button>
                        <button class="filter-btn w-full text-left p-2 rounded-lg border hover:bg-gray-50" data-filter="at-risk">
                            <i class="fas fa-exclamation-triangle mr-2"></i>At Risk
                        </button>
                        <button class="filter-btn w-full text-left p-2 rounded-lg border hover:bg-gray-50" data-filter="new">
                            <i class="fas fa-seedling mr-2"></i>New Customers
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 overflow-y-auto p-6">
            <!-- Metrics Overview -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
                <div class="metric-card p-6 rounded-xl">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-blue-100">Total Customers</p>
                            <p class="text-3xl font-bold" id="totalCustomers">0</p>
                        </div>
                        <i class="fas fa-users text-3xl text-blue-200"></i>
                    </div>
                </div>
                <div class="metric-card p-6 rounded-xl">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-blue-100">High Value</p>
                            <p class="text-3xl font-bold" id="highValueCustomers">0</p>
                        </div>
                        <i class="fas fa-crown text-3xl text-blue-200"></i>
                    </div>
                </div>
                <div class="metric-card p-6 rounded-xl">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-blue-100">At Risk</p>
                            <p class="text-3xl font-bold" id="atRiskCustomers">0</p>
                        </div>
                        <i class="fas fa-exclamation-triangle text-3xl text-blue-200"></i>
                    </div>
                </div>
                <div class="metric-card p-6 rounded-xl">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-blue-100">Avg. Value</p>
                            <p class="text-3xl font-bold" id="avgCustomerValue">$0</p>
                        </div>
                        <i class="fas fa-dollar-sign text-3xl text-blue-200"></i>
                    </div>
                </div>
            </div>

            <!-- Charts Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <!-- RFM 3D Scatter Plot -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-scatter mr-2"></i>Customer Clusters (3D RFM)
                    </h3>
                    <div class="chart-container chart-container-3d">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="rfmChart"></div>
                    </div>
                </div>

                <!-- PCA 2D Visualization -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-line mr-2"></i>Customer Clusters (PCA 2D)
                    </h3>
                    <div class="chart-container">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="pcaChart"></div>
                    </div>
                </div>
            </div>

            <!-- Clustering Analysis -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <!-- Elbow Method -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-line mr-2"></i>WCSS vs. Number of Clusters (Elbow Method)
                    </h3>
                    <div class="chart-container chart-container-small">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="elbowChart"></div>
                    </div>
                </div>

                <!-- Silhouette Analysis -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-bar mr-2"></i>Silhouette Score vs. Number of Clusters
                    </h3>
                    <div class="chart-container chart-container-small">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="silhouetteChart"></div>
                    </div>
                </div>
            </div>

            <!-- Customer Segments Distribution -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <!-- Customer Segments Pie Chart -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-pie mr-2"></i>Customer Segments Distribution
                    </h3>
                    <div class="chart-container chart-container-small">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="segmentsChart"></div>
                    </div>
                </div>

                <!-- RFM Heatmap -->
                <div class="dashboard-card p-6">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-th mr-2"></i>RFM Score Heatmap
                    </h3>
                    <div class="chart-container chart-container-small">
                        <div class="loading">
                            <i class="fas fa-spinner fa-spin text-2xl text-blue-600"></i>
                        </div>
                        <div id="heatmapChart"></div>
                    </div>
                </div>
            </div>

            <!-- Customer Personas Table -->
            <div class="dashboard-card p-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                    <i class="fas fa-table mr-2"></i>Customer Personas
                </h3>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Customer ID</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Segment</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Recency</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Frequency</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Monetary</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">RFM Score</th>
                                <th class="px-4 py-3 text-left font-medium text-gray-700">Cluster</th>
                            </tr>
                        </thead>
                        <tbody id="personasTable" class="divide-y divide-gray-200">
                            <tr>
                                <td colspan="7" class="px-4 py-8 text-center text-gray-500">
                                    Upload a CSV file to see customer personas
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let rawData = [];
        let customerData = [];
        let rfmData = [];
        let clusterData = [];
        let columnMapping = {};
        let pcaData = null;
        let elbowData = [];
        let silhouetteData = [];

        // ML Algorithms
        const ML = window.mlMatrix || window.Matrix;

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('loadData').addEventListener('click', loadCustomerData);
            document.getElementById('calculateRFM').addEventListener('click', calculateRFM);
            document.getElementById('runClustering').addEventListener('click', runClustering);
            document.getElementById('toggleSidebar').addEventListener('click', toggleSidebar);
            document.getElementById('exportBtn').addEventListener('click', exportReport);
            
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('filter-active'));
                    this.classList.add('filter-active');
                    applyFilter(this.dataset.filter);
                });
            });
        }

        function loadCustomerData() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a CSV file first');
                return;
            }

            showLoading();
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    rawData = results.data.filter(row => {
                        // Filter out completely empty rows
                        return Object.values(row).some(val => val && val.toString().trim() !== '');
                    });
                    
                    if (rawData.length === 0) {
                        alert('No data found in CSV file');
                    hideLoading();
                        return;
                    }

                    // Auto-detect column mapping
                    detectColumnMapping(rawData[0]);
                    
                    // Process data
                    processRawData();
                    
                    updateDataInfo(rawData.length, Object.keys(rawData[0] || {}).length);
                    hideLoading();
                    
                    // Auto-calculate RFM
                    calculateRFM();
                },
                error: function(error) {
                    console.error('Error parsing CSV:', error);
                    alert('Error loading CSV file: ' + error.message);
                    hideLoading();
                }
            });
        }

        function detectColumnMapping(firstRow) {
            const keys = Object.keys(firstRow).map(k => k.toLowerCase().trim());
            
            // Find customer ID column
            columnMapping.customerId = keys.find(k => 
                k.includes('customer') || k.includes('id') || k.includes('customerid')
            ) || keys[0];
            
            // Find date column
            columnMapping.date = keys.find(k => 
                k.includes('date') || k.includes('invoice') || k.includes('purchase') || k.includes('order')
            );
            
            // Find amount column
            columnMapping.amount = keys.find(k => 
                k.includes('amount') || k.includes('price') || k.includes('value') || 
                k.includes('total') || k.includes('revenue') || k.includes('spent')
            );
            
            // Display mapping
            const mappingText = `Detected: Customer=${columnMapping.customerId}, Date=${columnMapping.date || 'Not found'}, Amount=${columnMapping.amount || 'Not found'}`;
            document.getElementById('columnMapping').textContent = mappingText;
        }

        function processRawData() {
            // Group by customer
            const customerMap = {};
            
            rawData.forEach(row => {
                const customerId = row[columnMapping.customerId] || row[Object.keys(row)[0]];
                const dateStr = columnMapping.date ? row[columnMapping.date] : null;
                const amount = parseFloat(columnMapping.amount ? row[columnMapping.amount] : 0) || 0;
                
                if (!customerId) return;
                
                if (!customerMap[customerId]) {
                    customerMap[customerId] = {
                        customer_id: customerId,
                        transactions: [],
                        dates: []
                    };
                }
                
                customerMap[customerId].transactions.push(amount);
                if (dateStr) {
                    const date = parseDate(dateStr);
                    if (date) customerMap[customerId].dates.push(date);
                }
            });
            
            // Convert to array
            customerData = Object.values(customerMap).map(customer => {
                const totalSpent = customer.transactions.reduce((a, b) => a + b, 0);
                const totalOrders = customer.transactions.length;
                const lastDate = customer.dates.length > 0 ? Math.max(...customer.dates) : null;
                const firstDate = customer.dates.length > 0 ? Math.min(...customer.dates) : null;
                
                const now = Date.now();
                const lastPurchaseDays = lastDate ? Math.floor((now - lastDate) / (1000 * 60 * 60 * 24)) : 365;
                
                return {
                    customer_id: customer.customer_id,
                    total_spent: totalSpent,
                    total_orders: totalOrders,
                    avg_order_value: totalOrders > 0 ? totalSpent / totalOrders : 0,
                    last_purchase_days: lastPurchaseDays,
                    first_date: firstDate,
                    last_date: lastDate
                };
            });
        }

        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // Try various date formats
            const formats = [
                /^\d{4}-\d{2}-\d{2}$/, // YYYY-MM-DD
                /^\d{2}\/\d{2}\/\d{4}$/, // MM/DD/YYYY
                /^\d{2}-\d{2}-\d{4}$/, // MM-DD-YYYY
            ];
            
            let date = null;
            
            // Try ISO format first
            date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date.getTime();
            
            // Try parsing manually
            const parts = dateStr.split(/[-\/\s]/);
            if (parts.length === 3) {
                if (parts[0].length === 4) {
                    // YYYY-MM-DD
                    date = new Date(parts[0], parts[1] - 1, parts[2]);
                } else {
                    // MM/DD/YYYY
                    date = new Date(parts[2], parts[0] - 1, parts[1]);
                }
                if (!isNaN(date.getTime())) return date.getTime();
            }
            
            return null;
        }

        function calculateRFM() {
            if (customerData.length === 0) {
                alert('Please load customer data first');
                return;
            }

            showLoading();
            
            // Calculate RFM metrics
            const recencies = customerData.map(c => c.last_purchase_days);
            const frequencies = customerData.map(c => c.total_orders);
            const monetaries = customerData.map(c => c.total_spent);
            
            // Calculate quartiles for scoring
            const rQuartiles = calculateQuartiles(recencies);
            const fQuartiles = calculateQuartiles(frequencies);
            const mQuartiles = calculateQuartiles(monetaries);
            
            // Assign RFM scores (1-5 scale, higher is better)
            rfmData = customerData.map(customer => {
                // Recency: lower days = higher score (recent purchase is good)
                let rScore = 1;
                if (customer.last_purchase_days <= rQuartiles.q1) rScore = 5;
                else if (customer.last_purchase_days <= rQuartiles.q2) rScore = 4;
                else if (customer.last_purchase_days <= rQuartiles.q3) rScore = 3;
                else if (customer.last_purchase_days <= rQuartiles.q4) rScore = 2;
                
                // Frequency: higher orders = higher score
                let fScore = 1;
                if (customer.total_orders >= fQuartiles.q4) fScore = 5;
                else if (customer.total_orders >= fQuartiles.q3) fScore = 4;
                else if (customer.total_orders >= fQuartiles.q2) fScore = 3;
                else if (customer.total_orders >= fQuartiles.q1) fScore = 2;
                
                // Monetary: higher spent = higher score
                let mScore = 1;
                if (customer.total_spent >= mQuartiles.q4) mScore = 5;
                else if (customer.total_spent >= mQuartiles.q3) mScore = 4;
                else if (customer.total_spent >= mQuartiles.q2) mScore = 3;
                else if (customer.total_spent >= mQuartiles.q1) mScore = 2;

                return {
                    ...customer,
                    recency: customer.last_purchase_days,
                    frequency: customer.total_orders,
                    monetary: customer.total_spent,
                    r_score: rScore,
                    f_score: fScore,
                    m_score: mScore,
                    rfm_score: `${rScore}${fScore}${mScore}`,
                    segment: getSegment(rScore, fScore, mScore)
                };
            });

            updateMetrics();
            createRFMChart();
            createSegmentsChart();
            createHeatmapChart();
            updatePersonasTable();
            hideLoading();
        }

        function calculateQuartiles(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q2 = sorted[Math.floor(sorted.length * 0.5)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const q4 = sorted[sorted.length - 1];
            return { q1, q2, q3, q4 };
        }

        function getSegment(r, f, m) {
            if (r >= 4 && f >= 4 && m >= 4) return 'Champions';
            if (r >= 3 && f >= 3 && m >= 4) return 'Loyal Customers';
            if (r >= 4 && f >= 2 && m >= 3) return 'Potential Loyalists';
            if (r >= 3 && f >= 2 && m >= 2) return 'New Customers';
            if (r >= 2 && f >= 3 && m >= 3) return 'Promising';
            if (r >= 2 && f >= 2 && m >= 2) return 'Need Attention';
            if (r >= 1 && f >= 2 && m >= 2) return 'About to Sleep';
            if (r >= 1 && f >= 1 && m >= 1) return 'At Risk';
            return 'Lost';
        }

        function updateMetrics() {
            const total = rfmData.length;
            const highValue = rfmData.filter(c => c.segment === 'Champions' || c.segment === 'Loyal Customers').length;
            const atRisk = rfmData.filter(c => c.segment === 'At Risk' || c.segment === 'Lost').length;
            const avgValue = rfmData.reduce((sum, c) => sum + c.monetary, 0) / total;

            document.getElementById('totalCustomers').textContent = total;
            document.getElementById('highValueCustomers').textContent = highValue;
            document.getElementById('atRiskCustomers').textContent = atRisk;
            document.getElementById('avgCustomerValue').textContent = `$${Math.round(avgValue).toLocaleString()}`;
        }

        function runClustering() {
            if (rfmData.length === 0) {
                alert('Please calculate RFM scores first');
                return;
            }

            showLoading();
            
            setTimeout(() => {
                const numClusters = parseInt(document.getElementById('numClusters').value) || 4;
                
                // Prepare data for clustering (normalize RFM values)
                const features = rfmData.map(c => [
                    c.recency / Math.max(...rfmData.map(d => d.recency)),
                    c.frequency / Math.max(...rfmData.map(d => d.frequency)),
                    c.monetary / Math.max(...rfmData.map(d => d.monetary))
                ]);
                
                // Run K-Means clustering
                const clusters = kMeansClustering(features, numClusters);
                
                // Calculate elbow and silhouette scores for different K values
                calculateElbowAndSilhouette(features);
                
                // Assign clusters
                clusterData = rfmData.map((customer, idx) => ({
                    ...customer,
                    cluster: clusters[idx]
                }));
                
                // Perform PCA
                performPCA(features);
                
                // Update charts
                createPCAChart();
                createElbowChart();
                createSilhouetteChart();
                createRFMChart();
                updatePersonasTable();
                
                hideLoading();
            }, 100);
        }

        function kMeansClustering(data, k, maxIterations = 100) {
            const n = data.length;
            const dim = data[0].length;
            
            // Initialize centroids randomly
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push(data[Math.floor(Math.random() * n)].slice());
            }
            
            let assignments = new Array(n);
            let prevAssignments = null;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Assign points to nearest centroid
                for (let i = 0; i < n; i++) {
                    let minDist = Infinity;
                    let closest = 0;
                    for (let j = 0; j < k; j++) {
                        const dist = euclideanDistance(data[i], centroids[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = j;
                        }
                    }
                    assignments[i] = closest;
                }
                
                // Check for convergence
                if (prevAssignments && arraysEqual(assignments, prevAssignments)) {
                    break;
                }
                prevAssignments = [...assignments];
                
                // Update centroids
                for (let j = 0; j < k; j++) {
                    const clusterPoints = data.filter((_, i) => assignments[i] === j);
                    if (clusterPoints.length > 0) {
                        centroids[j] = clusterPoints[0].map((_, d) => 
                            clusterPoints.reduce((sum, p) => sum + p[d], 0) / clusterPoints.length
                        );
                    }
                }
            }
            
            return assignments;
        }

        function euclideanDistance(a, b) {
            return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));
        }

        function arraysEqual(a, b) {
            return a.length === b.length && a.every((val, i) => val === b[i]);
        }

        function calculateElbowAndSilhouette(features) {
            elbowData = [];
            silhouetteData = [];
            
            for (let k = 2; k <= 8; k++) {
                const clusters = kMeansClustering(features, k);
                
                // Calculate WCSS (Within-Cluster Sum of Squares)
                let wcss = 0;
                const centroids = [];
                
                for (let j = 0; j < k; j++) {
                    const clusterPoints = features.filter((_, i) => clusters[i] === j);
                    if (clusterPoints.length > 0) {
                        const centroid = clusterPoints[0].map((_, d) => 
                            clusterPoints.reduce((sum, p) => sum + p[d], 0) / clusterPoints.length
                        );
                        centroids.push(centroid);
                        
                        clusterPoints.forEach(point => {
                            wcss += Math.pow(euclideanDistance(point, centroid), 2);
                        });
                    }
                }
                
                elbowData.push({ k, wcss: wcss / features.length });
                
                // Calculate silhouette score (simplified)
                let silhouetteSum = 0;
                for (let i = 0; i < features.length; i++) {
                    const cluster = clusters[i];
                    const sameCluster = features.filter((_, idx) => clusters[idx] === cluster);
                    const otherClusters = [...new Set(clusters)].filter(c => c !== cluster);
                    
                    const a = sameCluster.reduce((sum, p, idx) => 
                        idx === i ? sum : sum + euclideanDistance(features[i], p), 0
                    ) / (sameCluster.length - 1) || 0;
                    
                    const b = Math.min(...otherClusters.map(c => {
                        const otherPoints = features.filter((_, idx) => clusters[idx] === c);
                        return otherPoints.reduce((sum, p) => sum + euclideanDistance(features[i], p), 0) / otherPoints.length;
                    }));
                    
                    silhouetteSum += (b - a) / Math.max(a, b) || 0;
                }
                
                silhouetteData.push({ k, score: silhouetteSum / features.length });
            }
        }

        function performPCA(features) {
            // Simple PCA: calculate covariance matrix and eigen decomposition
            const n = features.length;
            const dim = features[0].length;
            
            // Center the data
            const mean = features[0].map((_, d) => 
                features.reduce((sum, p) => sum + p[d], 0) / n
            );
            
            const centered = features.map(p => p.map((val, d) => val - mean[d]));
            
            // Calculate covariance matrix (simplified - using first 2 principal components)
            // For simplicity, we'll use a basic approximation
            const pca1 = centered.map(p => p.reduce((sum, val, i) => sum + val * (i === 0 ? 0.7 : i === 1 ? 0.5 : 0.3), 0));
            const pca2 = centered.map(p => p.reduce((sum, val, i) => sum + val * (i === 0 ? -0.3 : i === 1 ? 0.7 : 0.4), 0));
            
            // Normalize
            const max1 = Math.max(...pca1.map(Math.abs));
            const max2 = Math.max(...pca2.map(Math.abs));
            
            pcaData = {
                pc1: pca1.map(v => v / max1),
                pc2: pca2.map(v => v / max2)
            };
        }

        function createRFMChart() {
            if (rfmData.length === 0) return;
            
            const traces = [];
            const clusterColors = ['#8B5CF6', '#F59E0B', '#10B981', '#EF4444', '#3B82F6', '#EC4899', '#14B8A6', '#F97316'];
            
            if (clusterData.length > 0) {
                // Group by cluster
                const clusters = {};
                clusterData.forEach((customer, idx) => {
                    const cluster = customer.cluster;
                    if (!clusters[cluster]) {
                        clusters[cluster] = {
                            x: [], y: [], z: [], ids: []
                        };
                    }
                    clusters[cluster].x.push(customer.recency);
                    clusters[cluster].y.push(customer.frequency);
                    clusters[cluster].z.push(customer.monetary);
                    clusters[cluster].ids.push(customer.customer_id);
                });
                
                Object.keys(clusters).forEach(cluster => {
                    const data = clusters[cluster];
            traces.push({
                        x: data.x,
                        y: data.y,
                        z: data.z,
                mode: 'markers',
                type: 'scatter3d',
                        name: `Cluster ${parseInt(cluster) + 1}`,
                marker: {
                            size: 5,
                            color: clusterColors[cluster % clusterColors.length],
                            opacity: 0.7
                        },
                        text: data.ids,
                        hovertemplate: 'Customer: %{text}<br>R: %{x}<br>F: %{y}<br>M: %{z}<extra></extra>'
                    });
                });
            } else {
                // No clustering yet, show by segment
                const segments = {};
                rfmData.forEach(customer => {
                    const seg = customer.segment;
                    if (!segments[seg]) {
                        segments[seg] = { x: [], y: [], z: [], ids: [] };
                    }
                    segments[seg].x.push(customer.recency);
                    segments[seg].y.push(customer.frequency);
                    segments[seg].z.push(customer.monetary);
                    segments[seg].ids.push(customer.customer_id);
                });
                
                const segmentColors = {
                    'Champions': '#10B981',
                    'Loyal Customers': '#3B82F6',
                    'At Risk': '#EF4444',
                    'Lost': '#6B7280'
                };
                
                Object.keys(segments).forEach(seg => {
                    const data = segments[seg];
            traces.push({
                        x: data.x,
                        y: data.y,
                        z: data.z,
                mode: 'markers',
                type: 'scatter3d',
                        name: seg,
                marker: {
                            size: 5,
                            color: segmentColors[seg] || '#8B5CF6',
                            opacity: 0.7
                        }
                    });
                });
            }

            const layout = {
                title: 'Customer Clusters (3D RFM)',
                scene: {
                    xaxis: { title: 'Recency (days)' },
                    yaxis: { title: 'Frequency (orders)' },
                    zaxis: { title: 'Monetary ($)' },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
                },
                margin: { l: 0, r: 0, t: 40, b: 0 },
                showlegend: true
            };

            Plotly.newPlot('rfmChart', traces, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function createPCAChart() {
            if (!pcaData || clusterData.length === 0) return;
            
            const traces = [];
            const clusterColors = ['#8B5CF6', '#F59E0B', '#10B981', '#EF4444', '#3B82F6', '#EC4899', '#14B8A6', '#F97316'];
            
            const clusters = {};
            clusterData.forEach((customer, idx) => {
                const cluster = customer.cluster;
                if (!clusters[cluster]) {
                    clusters[cluster] = { x: [], y: [], ids: [] };
                }
                clusters[cluster].x.push(pcaData.pc1[idx]);
                clusters[cluster].y.push(pcaData.pc2[idx]);
                clusters[cluster].ids.push(customer.customer_id);
            });
            
            Object.keys(clusters).forEach(cluster => {
                const data = clusters[cluster];
                traces.push({
                    x: data.x,
                    y: data.y,
                    mode: 'markers',
                    type: 'scatter',
                    name: `Cluster ${parseInt(cluster) + 1}`,
                marker: {
                        size: 8,
                        color: clusterColors[cluster % clusterColors.length],
                        opacity: 0.7
                    },
                    text: data.ids,
                    hovertemplate: 'Customer: %{text}<extra></extra>'
                });
            });

            const layout = {
                title: 'Customer Clusters (PCA 2D)',
                xaxis: { title: 'PCA Component 1', showgrid: true },
                yaxis: { title: 'PCA Component 2', showgrid: true },
                margin: { t: 40, b: 0, l: 0, r: 0 },
                showlegend: true,
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };
            
            Plotly.newPlot('pcaChart', traces, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function createElbowChart() {
            if (elbowData.length === 0) return;
            
            const data = [{
                x: elbowData.map(d => d.k),
                y: elbowData.map(d => d.wcss),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'WCSS',
                line: { color: '#2563eb', width: 3 },
                marker: { size: 8, color: '#2563eb' }
            }];

            const layout = {
                title: 'WCSS vs. Number of Clusters (Elbow Method)',
                xaxis: { title: 'Number of Clusters (K)', showgrid: true },
                yaxis: { title: 'WCSS (Inertia)', showgrid: true },
                margin: { t: 40, b: 0, l: 0, r: 0 },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };

            Plotly.newPlot('elbowChart', data, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function createSilhouetteChart() {
            if (silhouetteData.length === 0) return;
            
            const data = [{
                x: silhouetteData.map(d => d.k),
                y: silhouetteData.map(d => d.score),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Silhouette Score',
                line: { color: '#2563eb', width: 3 },
                marker: { size: 8, color: '#2563eb' }
            }];

            const layout = {
                title: 'Silhouette Score vs. Number of Clusters',
                xaxis: { title: 'Number of Clusters (K)', showgrid: true },
                yaxis: { title: 'Silhouette Score', showgrid: true },
                margin: { t: 40, b: 0, l: 0, r: 0 },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };

            Plotly.newPlot('silhouetteChart', data, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function createSegmentsChart() {
            if (rfmData.length === 0) return;
            
            const segmentCounts = {};
            rfmData.forEach(customer => {
                segmentCounts[customer.segment] = (segmentCounts[customer.segment] || 0) + 1;
            });
            
            const data = [{
                values: Object.values(segmentCounts),
                labels: Object.keys(segmentCounts),
                type: 'pie',
                marker: {
                    colors: ['#10B981', '#3B82F6', '#F59E0B', '#8B5CF6', '#EF4444', '#6B7280', '#EC4899', '#14B8A6']
                },
                textinfo: 'label+percent',
                textposition: 'outside'
            }];
            
            const layout = {
                title: 'Customer Segments Distribution',
                margin: { t: 40, b: 0, l: 0, r: 0 },
                showlegend: true,
                legend: { orientation: "v", x: 1.05, y: 0.5 }
            };
            
            Plotly.newPlot('segmentsChart', data, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function createHeatmapChart() {
            if (rfmData.length === 0) return;
            
            const heatmapData = [];
            for (let r = 1; r <= 5; r++) {
                const row = [];
                for (let f = 1; f <= 5; f++) {
                    const count = rfmData.filter(c => c.r_score === r && c.f_score === f).length;
                    row.push(count);
                }
                heatmapData.push(row);
            }
            
            const data = [{
                z: heatmapData,
                type: 'heatmap',
                colorscale: 'Blues',
                showscale: true,
                colorbar: { title: 'Customer Count' }
            }];
            
            const layout = {
                title: 'RFM Score Distribution Heatmap',
                xaxis: { title: 'Frequency Score', tickmode: 'linear', tick0: 1, dtick: 1 },
                yaxis: { title: 'Recency Score', tickmode: 'linear', tick0: 1, dtick: 1, autorange: 'reversed' },
                margin: { t: 40, b: 0, l: 0, r: 0 }
            };
            
            Plotly.newPlot('heatmapChart', data, layout, {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            });
        }

        function updatePersonasTable() {
            const tbody = document.getElementById('personasTable');
            tbody.innerHTML = '';

            const dataToShow = clusterData.length > 0 ? clusterData : rfmData;
            
            dataToShow.slice(0, 50).forEach(customer => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-4 py-3">${customer.customer_id}</td>
                    <td class="px-4 py-3">
                        <span class="px-2 py-1 rounded-full text-xs font-medium ${getSegmentColor(customer.segment)}">
                            ${customer.segment}
                        </span>
                    </td>
                    <td class="px-4 py-3">${customer.recency || customer.last_purchase_days} days</td>
                    <td class="px-4 py-3">${customer.frequency || customer.total_orders}</td>
                    <td class="px-4 py-3">$${Math.round(customer.monetary || customer.total_spent).toLocaleString()}</td>
                    <td class="px-4 py-3 font-mono">${customer.rfm_score}</td>
                    <td class="px-4 py-3">${customer.cluster !== undefined ? `Cluster ${customer.cluster + 1}` : '-'}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function getSegmentColor(segment) {
            const colors = {
                'Champions': 'bg-green-100 text-green-800',
                'Loyal Customers': 'bg-blue-100 text-blue-800',
                'Potential Loyalists': 'bg-yellow-100 text-yellow-800',
                'New Customers': 'bg-purple-100 text-purple-800',
                'Promising': 'bg-indigo-100 text-indigo-800',
                'Need Attention': 'bg-orange-100 text-orange-800',
                'About to Sleep': 'bg-red-100 text-red-800',
                'At Risk': 'bg-red-100 text-red-800',
                'Lost': 'bg-gray-100 text-gray-800'
            };
            return colors[segment] || 'bg-gray-100 text-gray-800';
        }

        function applyFilter(filter) {
            // Filter logic
            console.log('Applying filter:', filter);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }

        function exportReport() {
            const data = {
                customers: clusterData.length > 0 ? clusterData : rfmData,
                metrics: {
                    total: rfmData.length,
                    highValue: rfmData.filter(c => c.segment === 'Champions' || c.segment === 'Loyal Customers').length,
                    atRisk: rfmData.filter(c => c.segment === 'At Risk' || c.segment === 'Lost').length
                },
                elbowData,
                silhouetteData
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'customer-persona-report.json';
            a.click();
        }

        function updateDataInfo(rowCount, columnCount) {
            document.getElementById('rowCount').textContent = rowCount;
            document.getElementById('columnCount').textContent = columnCount;
            document.getElementById('dataInfo').classList.remove('hidden');
        }

        function showLoading() {
            document.querySelectorAll('.loading').forEach(loading => {
                loading.style.display = 'block';
            });
        }

        function hideLoading() {
            document.querySelectorAll('.loading').forEach(loading => {
                loading.style.display = 'none';
            });
        }
    </script>
</body>
</html>
